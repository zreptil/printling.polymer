<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-signin/google-signin.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="import.html">
<link rel="import" href="cloud-data-overlay.html">
<!--
`cloud-data` is an element that encapsulates some of the features of googles cloud
data. It uses the element google-signin for the communication with google webservices.

@demo demo/index.html
-->
<dom-module id="cloud-data">
  <template>
    <style is="custom-style">
      :host
      {
        @apply(--backdrop)
      }
      img
      {
        width: 50px;
      }
      paper-button
      {
        background: #a0a0ff;
      }
      google-signin
      {
        --google-signin-background: var(--paper-light-red-500);
      }
      @media(pointer:coarse)
      {
        body
        {
          background: red;
        }
        paper-button
        {
          font-size: 2em;
          padding: 1.7em 1.57em;
        }
      }
    </style>
    <google-signin id="button"
      allow-drive="{{allowDrive}}"
      allow-calendar="{{allowCalendar}}"
      allow-sheets="{{allowSheets}}"
      brand="google"
      client-id="{{googleClientId}}"
      signed-in="{{_signedIn}}"
      label-signout="{{googleUserName}}"
      on-google-signin-success="_handleSignIn"
      on-google-signed-out="_handleSignOut"
      is-authorized="{{_isAuthorized}}"
      disconnect-on-signout={{disconnectOnSignout}}
      openid-prompt="select_account"
    </google-signin>
    <cloud-data-overlay id="overlay" no-cancel-on-outside-click with-backdrop hide-overlay={{hideOverlay}}></cloud-data-overlay>
  </template>
</dom-module>
<script>
  // this variable is needed on a global level
  // since it is used to manage data-access
  // across callback-limits.
  var __cloudData = undefined;
  Polymer(
  {
    is: "cloud-data",
    properties:
    {
      /**
        * True, when the user authorized this element.
        */
       _isAuthorized: {type: Boolean, value: false}
      /**
        * True, when the user signed in to Google.
        */
      ,_signedIn: {type: Boolean, value: false}
      /**
        * if true, the access to handle files in google drive will be requested when signing in.
        */
      ,allowDrive: {type: Boolean, value: true}
      /**
        * if true, the access to google calendar will be requested when signing in.
        */
      ,allowCalendar: {type: Boolean, value: false}
      /**
        * if true, the access to google sheets will be requested when signing in.
        */
      ,allowSheets: {type: Boolean, value: false}
      /**
        * The scopes that are needed to do the work. This should not be changed, unless the code
        * changes and more scopes are required.
        */
      ,_scopes: {type:String, value: ""}
      /**
        * if true, the client is disconnected when the user signs out from google.
        */
      ,disconnectOnSignout: {type:Boolean, value: false}
      /**
        * id for google webapp that wants to use this component.
        * can be found in the google api manager at
        * https://console.developers.google.com/apis/credentials/oauthclient.
        */
     ,googleClientId: {type: String, value: ""}
      /**
        * id for file that should be accessed with google sheets api.
        * starts with https://docs.google.com/spreadsheets/d/ and is the
        * link, you get, when linking to a sheet.
        */
     ,googleSheetsFileId: {type: String, value: ""}
      /**
        * css-selector of a html-element. this element is hidden, when signed-in to google and shown when not signed-in.
        */
     ,googleSigninHideSelector: {type: String, value: ""}
      /**
       *  css-selector of a html-element. this element is shown, when signed-in to google and hidden when not signed-in.
       *  if this element has a method named `msg` then this method is called whenever cloud-data wants to tell the
       *  user something.
       */
     ,googleSigninShowSelector: {type: String, value: ""}
      /**
        * the status of the connection to google. Can be "signin granted" or "signed out".
        */
     ,googleStatus: {type: String, value: "Not granted"}
      /**
        * the email-address of the user, when signed in to google.
        */
     ,googleUserEmail: {type: String, value: ""}
      /**
        * the image of the user, when signed in to google.
        */
     ,googleUserImg: {type: String, value: ""}
      /**
        * the name of the user, when signed in to google.
        */
     ,googleUserName: {type: String, value: "N/A"}
      /**
        * if true, then the element gives some additional information when doing work.
        */
     ,isDebug: {type:Boolean, value:false}
      /**
        * if not present, then an overlay with a message is shown when executing timeconsuming tasks.
        */
     ,hideOverlay: {type: Boolean, value: false}
      /**
        * if set, then all messages that are created by api-calls are replaced with this text.
        */
     ,overlayMsg: {type: String, value: undefined}
    },
    ready: function()
    {
      // set the scopes needed by calls to _callGoogleApi
      this.scDrive = "https://www.googleapis.com/auth/drive ";
      this.scCalendar = "https://www.googleapis.com/auth/calendar ";
      this.scSheets = "https://www.googleapis.com/auth/spreadsheets ";
      
      this.handlingSignOut = false;
      this.dataPool = [];
      this.dataRequests = [];
      try
      {
        this.hideControl = document.querySelector(this.googleSigninHideSelector);
        this.hideControl.removeAttribute("hidden");
      }
      catch(ex)
      {
        this.hideControl = undefined;
      }
      try
      {
        this.showControl = document.querySelector(this.googleSigninShowSelector);
        this.showControl.setAttribute("hidden","");
      }
      catch(ex)
      {
        this.showControl = undefined;
      }

      document.body.appendChild(this.$.overlay);
    },
    /**
     * Calls the api of google.
     *
     * @param {String}  msg          message to display on overlay.
     *
     * @param {String}  scopes       the scopes needed for that api call.
     *
     * @param {Event}   callback     function to be called when authorization succeeded.
     */
    _callGoogleApi: function(msg,scopes,callback,skipTimeout)
    {
      // up to now it is not possible to change the scope after login
      // this._scopes = scopes;
      if(skipTimeout == undefined && this.hideOverlay)
      {
        setTimeout(this._callGoogleApi(msg,scopes,callback,true),10);
        return;
      }

      if(!gapi.auth)
      {
        gapi.load("auth",function()
        {
          if(gapi.auth)
          {
            __cloudData.self._callGoogleApi(msg,scopes,callback,true);
          }
          else
          {
            alert("Auth-API konnte nicht geladen werden.");
            __cloudData = undefined;
          }
        });
        return;
      }
      if(!gapi.client)
      {
        gapi.load("client",function()
        {
          if(gapi.client)
          {
            __cloudData.self._callGoogleApi(msg,scopes,callback,true);
          }
          else
          {
            alert("Client-API konnte nicht geladen werden.");
            __cloudData = undefined;
          }
        });
        return;
      }

      if(this.overlayMsg != undefined)
        msg = this.overlayMsg;

      if(!this.$.overlay.isCanceled)
        this.$.overlay.show(msg);
      if(__cloudData == undefined)
      __cloudData = {self: this};
      // up to now every possible scope has to be defined when signing in
      var scopes = "";
      if(this.allowDrive)
        scopes += this.scDrive;
      if(this.allowCalendar)
        scopes += this.scCalendar;
      if(this.allowSheets)
        scopes += this.scSheets;
      this.$.button.scopes = scopes;
      gapi.auth.authorize(
      {
        "client_id": this.googleClientId,
        "scope": scopes,
        "immediate": true,
        "authuser": this._googleAuthUser
      }, function(authResult)
      {
        if (authResult && !authResult.error)
        {
          callback(authResult);
          return;
        }
        __cloudData.self.$.overlay.showCancelButton = true;
        var errMsg = "unknown";
        if(authResult)
        {
          if(authResult.error_description)
            errMsg = authResult.error_description;
          else if(authResult.error)
            errMsg = authResult.error;
        }
        __cloudData.self.$.overlay.text = "error when accessing google-api: " + errMsg;
        __cloudData.self.$.overlay.showCancelButton = false;
      },function(error)
      {
        __cloudData.self.$.overlay.text = "error when accessing google-api: " + error;
      });
    },
    _handleSignIn: function(response)
    {
      this.googleStatus = "signin granted";
      this._googleAuthUser = gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().session_state.extraQueryParams.authuser;
      if(!this._googleAuthUser)
        this._googleAuthUser = "0";
      this.googleUserEmail = gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile().getEmail();
      this.googleUserName = gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile().getName();
      this.googleUserImg = gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile().getImageUrl();
      if(this.hideControl)
        this.hideControl.setAttribute("hidden","");
      if(this.showControl)
      {
        this.showControl.removeAttribute("hidden");
        if(this.showControl.signinDone)
          this.showControl.signinDone(this);
      }
      this.fire("status-change");
    },
    _handleSignOut: function(response)
    {
      if(this._handlingSignOut)
        return;

      this._handlingSignOut = true;
      this.googleUserImg = "";
      this.googleStatus = "signed out";
      this.googleUserName = "";
      if(this.hideControl)
        this.hideControl.removeAttribute("hidden");
      if(this.disconnectOnSignout)
        this.disconnect();
      if(this.showControl)
      {
        this.showControl.setAttribute("hidden","");
        if(this.showControl.signoutDone)
          this.showControl.signoutDone(this);
      }
      this._handlingSignOut = false;
      this.fire("status-change");
    },
    _msg: function(text)
    {
      if(this.showControl && this.showControl.msg)
        this.showControl.msg(text);
    },
    _msgDebug: function(text)
    {
      if(this.isDebug)
        console.log("[cloud-data] " + text);
    },
    /**
     * Diconnects the current user from google.
     */
    disconnect: function()
    {
      var currentUser = gapi.auth2.getAuthInstance().currentUser.get();
      if (currentUser)
        currentUser.disconnect();
      gapi.auth2.getAuthInstance().signOut();
    },
    /**
     * Executes a signout from google.
     */
    signOut: function()
    {
      this.$.button.signOut();
    },
    /**
     * Calls the google api for calendars.
     *
     * @param {Object}  parent   the parent that will be given as parameter to onDone. Since
     *                           the variable "this" is this class when invoking the onDone-
     *                           callback, parent should be set to the object, that contains the
     *                           functions onSuccess and onError.
     *
     * @param {String}  id       id of the calling function.
     *
     * @param {String} msg       message to display on overlay.
     *
     * @param {Event}  onSuccess the function that gets called when api was loaded.
     *
     * @param {Event}  onError   the function that gets called when api could not be loaded.
     *
     * the function onSuccess is called without parameters.
     *
     * the function onError receives this parameters:
     *
     * {Object} self   the parent parameter.
     *
     * {String} status always the string "error".
     *
     * {Object} error  the error object.
     */
    _callGoogleCalendarApi: function(parent,id,msg,onSuccess,onError)
    {
      this._callGoogleApi(msg,this.scSheets,function(authResult)
      {
        gapi.client.load("calendar","v3",function()
        {
          if(onSuccess)
            onSuccess();
        }, function(error)
        {
          __cloudData.self._apiError(parent,id,error,onError);
        });
      }, function(error)
      {
        __cloudData.self._apiError(parent,id,error,onError);
      });
    },
    /**
     * Request a list of calendars for the current user.
     *
     * @param {Object} parent    the parent that will be given as parameter to onCalendarListReceived
     * @param {Event}  onDone    the function that gets called when the list was received
     */
    requestCalendarList: function(parent,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["requestCalendarList",parent,onDone]);
        return;
      }

      __cloudData = {self: this};
      this._callGoogleCalendarApi(parent,"requestCalendarList","requesting calendar list...",function()
      {
        var request = gapi.client.calendar.calendarList.list({"key":""});
        request.execute(function(resp)
        {
          if (resp.error)
          {
            __cloudData.self._endRequest("requestCalendarList");
            __cloudData.self._msg("error retrieving calendar list: " + resp.message)
          }
          else
          {
            __cloudData.self._endRequest("requestCalendarList");
            if(onDone)
              onDone(parent,resp.items);
          }
        }.bind(this),function(error)
        {
          __cloudData.self._apiError(parent,"requestCalendarList",error,onDone);
        });
      });
    },
    /**
     * Add a notification to the specified calendar.
     *
     * @param {object} parent             the parent that will be given as parameter to onCalendarListReceived.
     * @param {string} calendarid         the id of the calendar to add the notification to.
     * @param {array}  eventList          list of event-Ids that will be checked before sending an event.
     * @param {string} time               the time for the notification in format "yyyymmddhhss".
     * @param {string} text               the text for the notification.
     * @param {event}  onNotificationSet  the function that gets called when notification was set.
     */
    addNotification: function(parent,calendarId,eventList,time,text,onNotificationSet)
    {
      if(!eventList)
        eventList = [];

      if(__cloudData != undefined)
      {
        this.dataRequests.push(["addNotification",parent,calendarId,eventList,time,text,onNotificationSet]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleApi("requesting calendar list...",this.scCalendar,function(authResult)
      {
        gapi.client.load("calendar","v3",function()
        {
          var start = time.substr(0,4)
                     +"-"+time.substr(4,2)
                     +"-"+time.substr(6,2)
                     +"T"+time.substr(8,2)
                     +":"+time.substr(10,2)
                     +":00";
          var evt =
          {
            summary: text
           ,description: "created by cloud-data"
           ,start:
            {
              dateTime: start
             ,timeZone: "Europe/Berlin"
            }
           ,end:
            {
              dateTime: start
             ,timeZone: "Europe/Berlin"
            }
           ,reminders:
            {
              useDefault: false
             ,overrides:
              [
                {method:"popup",minutes:"1"}
              ]
            }
          };
          var request = gapi.client.calendar.events.insert
          (
            {
              calendarId:calendarId
             ,resource:evt
            }
          );
          request.execute(function(resp)
          {
            if (resp.error)
            {
              __cloudData.self._msg("error when setting the notification: " + resp.message)
            }
            __cloudData.self._endRequest("addNotification");
            if(onNotificationSet)
              onNotificationSet(parent,new Date(resp.start.dateTime));
          }.bind(this));
        });
      });
    },
    /**
     * Create metadata for usage in an http-request from javascript object.
		 *
		 * @param {Object} data    the object to create metadata from.
     */
    _getMetadata: function(data)
    {
      var ret = "";
      if(data == undefined)
        return ret;
      var diff = "";
        
      for(var key in data)
      {
        if(data[key] instanceof Object)
          ret += diff + "\n \"" + key + "\":{" + this._getMetadata(data[key]) + "\n }";
        else
          ret += diff + "\n \"" + key + "\":\"" + data[key] + "\"";
        diff = ",";
      }
      
      return ret;
    },
    /**
     * Saves data to the cloud and calls onDataSaved afterwards.
     *
     * @param {Object} parent       the parent that will be given as parameter to onDataSaved.
     * @param {Object} data         the data that should be saved.
     * @param {String} ext          file extension without the dot.
     * @param {Event}  onDataSaved  the function that gets called when saving is done.
     *
     * the function onDataSaved receives this parameters:
     *
     * {Object}  parent  the parent that was given in saveData.
     *
     * {String}  status  the status of the operation:
     *
     *                   "ok"        everything is fine.
     *
     *                   "error"     the data property contains the response
     *                               as json-data.
     *
     *                   "modified"  the data on the server was modified since
     *                               the last call to requestData - nothing was saved.
     *
     *                   "canceled"  the data on the server was modified since
     *                               the last call to requestData and the check
     *                               was performed already.
     *
     * {Object}  data    the data that was saved or the json-data of the error.
     */
    saveData: function(parent,data,ext,onDataSaved)
    {
      if(ext == "")
      {
        var pos = data._id.lastIndexOf(".");
        if(pos >= 0)
        {
          ext = data._id.substr(pos+1);
          data._id = data._id.substr(0,pos);
        }
      }

      if(__cloudData != undefined)
      {
        this.dataRequests.push(["saveData",parent,data,ext,onDataSaved]);
        return;
      }

      this._msgDebug("saveData(" + data._id + "." + ext + ")");
      var found = false;
      for(var i=0; i<this.dataPool.length && !found; i++)
      {
        if(this.dataPool[i]._id == data._id)
        {
          this.dataPool[i] = this.cloneOf(data);
          found = true;
        }
      }
      if(!found)
        this.dataPool.push(this.cloneOf(data));

      __cloudData = {self:this,id:data._id};

      __cloudData.self._msgDebug("saveData: connecting to google-server...");
      this._callGoogleApi("saving data...",this.scDrive,function(authResult)
      {
        gapi.client.load("drive","v3",function()
        {
          var saveData = __cloudData.self.cloneOf(data);
          saveData._modified = undefined;
          saveData._fileId = undefined;
          saveData._id = undefined;
          saveData._ext = undefined;

          var saveText;
          if(ext == "json")
            saveText = JSON.stringify(saveData);
          else
            saveText = saveData.content;
          var accessToken = gapi.auth.getToken().access_token;
          var xhr = new XMLHttpRequest();
          var boundary = "--=#clouddata#=--";
          var mime = "text/plain";
          if(ext == "json")
            mime = "application/json";
          var temp = "--" + boundary;
          var metadata = "{\n \"title\":\"";
          if(data._id)
            metadata += data._id;
          else
            metadata += data.name;
          
          if(metadata.substr(metadata.length - ext.length - 1) != "." + ext)
            metadata += "." + ext;
          metadata += "\"";
          
          if(saveData.metadata != undefined)
            metadata += "," + __cloudData.self._getMetadata(saveData.metadata);
          metadata += "\n}";
          temp += "\nContent-Type: application/json; charset=UTF-8\n\n" + metadata + "\n\n";
          temp += "--" + boundary + "\nContent-Type: " + mime + "\n\n" + saveText + "\n";
          temp += "--" + boundary + "--";
          saveData = temp;

          if(data._fileId)
          {
            __cloudData.self._msgDebug("saveData: requesting file " + data._id + "." + ext + " for modification check...");
            var accessToken = gapi.auth.getToken().access_token;
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "https://www.googleapis.com/drive/v3/files/" + data._fileId + "?fields=modifiedTime");
            xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
            xhr.onload=function()
            {
              var file = JSON.parse(xhr.responseText);
              if(data._modified != file.modifiedTime)
              {
                if(data._alreadyModChecked)
                {
                  __cloudData.self._msgDebug("saveData: file was modified - second check, operation canceled");
                  __cloudData.self.$.overlay.close();
                  if(onDataSaved)
                    onDataSaved(parent,"canceled",data);
                  delete(data._alreadyModChecked);
                  return;
                }
                __cloudData.self._msgDebug("saveData: file was modified, "+(onDataSaved?"sending modified-status to app":"operation canceled"));
                __cloudData.self.$.overlay.close();
                __cloudData = undefined;
//                  data._alreadyModChecked = true;
                data._modified = file.modifiedTime;
                if(onDataSaved)
                  onDataSaved(parent,"modified",data);
                return;
              }
              __cloudData.self._msgDebug("saveData: file was not modified - saving file");
              xhr = new XMLHttpRequest();
              xhr.open("PUT", "https://www.googleapis.com/upload/drive/v2/files/" + data._fileId + "?uploadType=multipart");
              xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
              xhr.setRequestHeader("Content-Type", "multipart/related; boundary=" + boundary);
              xhr.onload=function()
              {
                if(xhr.status == 200)
                {
                  __cloudData.self._saveResult(xhr.responseText,parent,"ok",onDataSaved,data,ext);
                }
                else
                {
                  __cloudData.self._msg(__cloudData.self._getError("error in cloud-data.saveData:",JSON.parse(xhr.response)));
                  __cloudData.self._saveResult(xhr.responseText,parent,xhr.status,onDataSaved,data,ext);
                }
              };
              xhr.onerror=function()
              {
                __cloudData.self._saveResult(xhr.responseText,parent,"error",onDataSaved,data,ext);
              };
              xhr.send(saveData);
            };
            xhr.send();
            return;
          }
          else // saving new file
          {
            if(this.isDebug)this.$.overlay.show("creating new file...");
            xhr.open("POST", "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart");
            xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
            xhr.setRequestHeader("Content-Type", "multipart/related; boundary=" + boundary);
            xhr.onload=function()
            {
              if(xhr.status == 200)
              {
                __cloudData.self._saveResult(xhr.responseText,parent,"ok",onDataSaved,data,ext);
              }
              else
              {
                __cloudData.self._msg(__cloudData.self._getError("error in cloud-data.saveData:",JSON.parse(xhr.response)));
                __cloudData.self._saveResult(xhr.responseText,parent,xhr.status,onDataSaved,data,ext);
              }
            };
            xhr.onerror=function()
            {
              __cloudData.self._saveResult(xhr.responseText,parent,"error",onDataSaved,data,ext);
            };
            xhr.send(saveData);
          }
        });
      });
    },
    _saveResult: function(text,parent,status,onDataSaved,data,ext)
    {
      try
      {
        resp = JSON.parse(text);
        data._id = __cloudData.id;
        data._ext = ext;
        data._fileId = resp.id;
        data._modified = resp.modifiedDate;
        __cloudData.self.$.overlay.close();
        __cloudData = undefined;
      }
      catch(e)
      {
        this._msg("_saveResult("+text+","+status+","+__cloudData.id+","+ext+")");
      }
      if(onDataSaved)
        onDataSaved(parent,status,data);
    },
    /**
     * Creates a clone of an object.
     *
     * @param {Object} obj    the object that should be cloned.
     */
    cloneOf: function(obj)
    {
      var copy;

      // handle the 3 simple types, and null or undefined
      if (null == obj || "object" != typeof obj)
        return obj;

      // handle Date
      if (obj instanceof Date)
      {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
      }

      // handle Array
      if (obj instanceof Array)
      {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++)
          copy[i] = this.cloneOf(obj[i]);
        return copy;
      }

      // handle Object
      if (obj instanceof Object)
      {
        copy = {};
        for (var attr in obj)
        {
          if (obj.hasOwnProperty(attr))
            copy[attr] = this.cloneOf(obj[attr]);
        }
        return copy;
      }

      throw new Error("Unable to copy obj! Its type isn't supported.");
    },
    /**
     * Checks, if the data that should be saved was changed on the server since it was loaded.
     *
     * @param {Object} parent         the parent that will be used for sending callbacks.
     * @param {Object} data           the data that should be checked.
     * @param {Event}  onDataChecked  the function that is called when checking was done.
     */
    checkModifiedOnServer: function(parent,data,onDataChecked)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["checkModifiedOnServer",parent,data,onDataChecked]);
        return;
      }

      __cloudData = {self:this, id:data.id};
      this._callGoogleApi("",this.scDrive,function(authResult)
      {
        gapi.client.load("drive","v3",function()
        {
          var accessToken = gapi.auth.getToken().access_token;
          var xhr = new XMLHttpRequest();
          xhr.open("GET", "https://www.googleapis.com/drive/v3/files/" + data._fileId + "?fields=modifiedTime");
          xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
          xhr.onload=function()
          {
            __cloudData.self._checkResult(data,ext,xhr.responseText,parent,dataChecked);
            __cloudData.self._endRequest(data.id);
          };
          xhr.onerror=function()
          {
            __cloudData.self._msg(resp.message);
            __cloudData.self._endRequest(data.id);
          };
          xhr.send();
          return;
        });
      });
    },
    _checkResult: function(data,ext,text,parent,dataChecked)
    {
      try
      {
        var file = text;
        if(ext=="json")
          file = JSON.parse(text);
        if(dataChecked)
          dataChecked(parent,data._modified,file.modifiedTime);
      }
      catch(e)
      {
        this._msg("error in cloud-data._checkResult("+data._fileId+","+text+"): "+e);
        data = {_id:__cloudData.id};
      }
    },
    /**
     * Creates an errorstring from a response.
     * 
     * @param {String} msg       the message to prepend to the error information.
     *
     * @param {Object} response  the response of the server with the error information.
     */
    _getError: function(msg,response)
    {
      if(response.data && response.data.length > 0)
      {
        for(var i=0; i<response.data.length; i++)
        {
          var e = response.data[i];
          msg += "\n" + i + " - location = " + e.location + ", type = " + e.locationType;
        }
        msg += "\n";
      }
      if(response.error && response.error.errors.length > 0)
      {
        for(var i=0; i<response.error.errors.length; i++)
        {
          var e = response.error.errors[i];
          msg += "\n" + i + " - location = " + e.message + ", reason = " + e.reason;
        }
        msg += "\n";
      }
      
      return msg + response.message;
    },
    /**
     * Request list of files from server. the list contains a maximum of 1000 files.
     *
     * @param {Object} parent       the parent that will be given as parameter to onDataLoaded.
     *
     * @param {String} filemask     filemask for files.
     *
     * @param {Event}  onListLoaded the function that gets called when loading is done.
     *
     * @param {String} fields       the fields that are requested from the server (default id,name,trashed).
     *                              (https://developers.google.com/drive/v3/reference/files/list#try-it)
     *
     * @param {String} query        the query to execute. if this is empty then "name contains 'filemask'"
     *                              is used.
     *
     * the function onListLoaded receives this parameters:
     *
     * {Object} parent  the parent that was given in reqeustData.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the id as property _id.
     *
     * {Array}  list    the list of found files.
     */
    requestFileList: function(parent,filemask,onListLoaded,fields,query)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["requestFileList",parent,filemask,onListLoaded,fields,query]);
        return;
      }

      if(fields == undefined)
        fields = "id,name";

      if(fields.indexOf("trashed")<0)
        fields += ",trashed";

      if(query == undefined)
        query = "name contains '" + filemask + "'";

      __cloudData = {self:this, id:"filelist"};
      this._callGoogleApi("searching files...",this.scDrive,function(authResult)
      {
        gapi.client.load("drive","v3",function()
        {
          var request = gapi.client.drive.files.list(
          {
            "pageSize": 1000,
            "fields": "nextPageToken,files(" + fields + ")",
            "orderBy": "name",
            "q": query
          });
          request.execute(function(resp)
          {
            var files = resp.files;
            var status = "ok";
            if(files == undefined)
            {
              status = "error";
              files = __cloudData.self._getError("error in cloud-data.requestFileList:",resp);
              __cloudData.self._msg(files)
            }
            else
            {
              for(var i=0; i<files.length; i++)
              {
                var keep = !files[i].trashed;
                if(!keep)
                {
                  files.splice(i,1);
                  i--;
                }
              }
            }
            if(onListLoaded)
              onListLoaded(parent,status,files);
            __cloudData.self._endRequest("requestFileList");
          });
        });
      });
    },
    /**
     * Request data from server.
     *
     * @param {String}  id           id of the file to request. in fact the filename without extension.
     * @param {String}  ext          file extension without the dot. if this is empty, then the
     *                               extension is extracted from the id.
     * @param {Object}  parent       the parent that will be given as parameter to onDataLoaded. Since
     *                               the variable "this" is this class when invoking the onDataLoaded-
     *                               callback, parent should be set to the object, that contains the
     *                               function onDataLoaded.
     * @param {Event}   onDataLoaded the function that gets called when loading is done.
     *
     * @param {String}  msg          the message to display during load.
     *
     * @param {Boolean} skipDataPool if true, then the data will not be looked up in the datapool.
     *
     * @param {String}  query        when set, this query will be used to locate the datafile and not
     *                               the id. But the id will still be used to locate the file in the
     *                               datapool.
     *
     * the function onDataLoaded receives this parameters:
     *
     * {Object} self    the parent parameter that was given in requestData.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the id as property _id.
     *
     * {Object} data    the data that was loaded or the json-data of the error
     *
     * The data that is given back, is an object. When the requested datafile was a JSON-file then the
     * object contains the converted json-content of the file. When the requested datafile was not json,
     * then the object has a property "content" that contains the content of the file.
     *
     * The object always has the following properties:
     *
     * {String} _id      the name of the file without extension.
     *
     * {String} _fileId  the unique id of the file in the google drive system. This value is used
     *                   by the function saveData to save the file. If _fileId is not present in the
     *                   object, then a new file is created.
     */
    requestData: function(id,ext,parent,onDataLoaded,msg,skipDataPool,query)
    {
      if(ext == "")
      {
        var pos = id.lastIndexOf(".");
        if(pos >= 0)
        {
          ext = id.substr(pos+1);
          id = id.substr(0,pos);
        }
      }

      if(__cloudData != undefined)
      {
        this.dataRequests.push(["requestData",id,ext,parent,onDataLoaded,msg,skipDataPool]);
        return;
      }

      __cloudData = {self:this, id:id};
      var data = undefined;
      if(skipDataPool == undefined || !skipDataPool)
      {
        for(var i=0; i<this.dataPool.length && data == undefined; i++)
        {
          if(this.dataPool[i]._id == __cloudData.id)
            data = this.cloneOf(this.dataPool[i]);
        }
      }

      if(!msg)
        msg = "loading data...";
      if(!data)
      {
        this._callGoogleApi(msg,this.scDrive,function(authResult)
        {
          gapi.client.load("drive","v3",function()
          {
            if(id.substr(0,1) == "@")
            {
              var req = gapi.client.drive.files.get(
              {
                "fileId": id.substr(1)
               ,"alt": "media"
               ,"fields": "files(idx,name,trashed)"
              });
              req.then(function(content)
              {
                __cloudData.self._requestResult(content,ext,parent,onDataLoaded,{id:id.substr(1)});
                __cloudData.self._endRequest(id);
              },function(error)
              {
                __cloudData.self._requestResult(content,ext,parent,onDataLoaded,{id:id.substr(1)});
                __cloudData.self._endRequest(id);
              });
              return;
            }
            
            var request = gapi.client.drive.files.list(
            {
              "pageSize": 1000,
              "fields": "nextPageToken, files(id, name, trashed, modifiedTime)",
              "q": "name='" + __cloudData.id + "." + ext + "'"
            });
            
            if(query != undefined)
              request.q = query;
            request.execute(function(resp)
            {
              var files = resp.files;
              if (files && files.length > 0)
              {
                for (var i = 0; i < files.length; i++)
                {
                  var file = files[i];
                  if(file.name.substr(0,__cloudData.id.length) == __cloudData.id && !file.trashed)
                  {
                    var req = gapi.client.drive.files.get(
                    {
                      "fileId": file.id
                     ,"alt": "media"
                     ,"fields": "files(idx,name,trashed)"
                    });
                    req.then(function(content)
                    {
                      __cloudData.self._requestResult(content,ext,parent,onDataLoaded,file);
                      __cloudData.self._endRequest(id);
                    });
/*
                    var accessToken = gapi.auth.getToken().access_token;
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", "https://www.googleapis.com/drive/v3/files/" + file.id + "?alt=media");
                    xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
                    xhr.onload=function()
                    {
                      __cloudData.self._driveResult(xhr.responseText,ext,parent,onDataLoaded,file);
                      __cloudData.self._endRequest(id);
                    };
                    xhr.onerror=function()
                    {
                      __cloudData.self._msg(resp.message);
                      __cloudData.self._endRequest(id);
                    };
                    xhr.send();
//*/
                    return;
                  }
                }
                __cloudData.self._requestResult({body:"{}"},ext,parent,onDataLoaded,{id:"",modifiedTime:""});
                __cloudData.self._endRequest(id);
              }
              else if(files)
              {
                __cloudData.self._requestResult({body:"{}"},ext,parent,onDataLoaded,{id:"",modifiedTime:""});
                __cloudData.self._endRequest(id);
              }
              else
              {
                __cloudData.self._msg(resp.message);
                __cloudData.self._endRequest(id);
              }
            });
          });
        });
      }
      else
      {
        if(onDataLoaded)
          onDataLoaded(parent,"ok",data);
        this._endRequest(id);
      }
    },
    _endRequest: function(id)
    {
      __cloudData = undefined;
      var doClose = true;

      if(this.$.overlay.isCanceled)
      {
        this.dataRequests.splice(0,this.dataRequests.length);
        this.$.overlay.isCanceled = false;
      }

      if(this.dataRequests.length > 0)
      {
        if(this.dataRequests[0].id == id)
          this.dataRequests.splice(0,1);

        if(this.dataRequests.length > 0)
        {
          var req = this.dataRequests[0];
          this.dataRequests.splice(0,1);
          doClose = false;
          switch(req[0])
          {
            case "requestData":
              setTimeout(this.requestData(req[1],req[2],req[3],req[4],req[5],req[6]),100);
              break;
            case "saveData":
              setTimeout(this.saveData(req[1],req[2],req[3],req[4]),100);
              break;
            case "requestFileList":
              setTimeout(this.requestFileList(req[1],req[2],req[3],req[4],req[5]),100);
              break;
            case "requestCalendarList":
              setTimeout(this.requestCalendarList(req[1],req[2]),100);
              break;
            case "addNotification":
              setTimeout(this.addNotification(req[1],req[2],req[3],req[4],req[5],req[6]),100);
              break;
            case "getBackupFile":
              setTimeout(this.getBackupFile(req[1],req[2]),100);
              break;
            case "_saveZip":
              setTimeout(this._saveZip(req[1]),100);
              break;
            case "loadSheetInfo":
              setTimeout(this.loadSheetInfo(req[1],req[2]),100);
              break;
            case "readSheetData":
              setTimeout(this.readSheetData(req[1],req[2],req[3]),100);
              break;
            case "writeSheetData":
              setTimeout(this.writeSheetData(req[1],req[2],req[3],req[4]),100);
              break;
            case "addSheet":
              setTimeout(this.addSheet(req[1],req[2],req[3]),100);
              break;
            case "copySheet":
              setTimeout(this.copySheet(req[1],req[2],req[3],req[4]),100);
              break;
            case "createSpreadsheet":
              setTimeout(this.createSpreadsheet(req[1],req[2],req[3]),100);
              break;
          }
        }
      }
      if(doClose)
        this.$.overlay.close();
    },
    _requestResult: function(content,ext,parent,onDataLoaded,file)
    {
      var status = "ok";
      var data;
      try
      {
        if(ext=="json")
          data = JSON.parse(content.body);
        else
          data = {content:content.body};
      }
      catch(e)
      {
        this._msgDebug("_requestResult("+content+","+__cloudData.id+","+file.id+"): "+e.message);
        data = {_id:__cloudData.id};
        status = "error";
      }
      this.dataPool.push(this.cloneOf(data));
      while(this.dataPool.length > 10)
        this.dataPool.splice(0, 1);
      data._id = __cloudData.id;
      data._fileId = file.id;
      data._ext = ext;
      data._modified = file.modifiedTime;
      if(onDataLoaded)
        onDataLoaded(parent,status,data);
    },
    _decode: function(content)
    {
      var ret = new Uint8Array(content.length);
      for (var i = 0; i < ret.length; i++)
        ret[i] = content.charCodeAt(i);
      return ret;
    },
    _getBackupFiles: function(zipfilename, pageToken)
    {
      if(!pageToken)
        __cloudData.self._zip = new JSZip();

      var request = gapi.client.drive.files.list(
      {
        "pageToken": pageToken,
        "pageSize": 100,
        "fields": "nextPageToken,files(id,name,trashed)",
        "orderBy": "name",
        "q": "name contains '" + __cloudData.id + "'"
      });

      request.then(function(response)
      {
        for(var i=0; i<response.result.files.length; i++)
        {
          if(__cloudData.self.$.overlay.isCanceled)
          {
            __cloudData.self._zip = undefined;
            __cloudData.self._endRequest("");
            return;
          }
          var file = response.result.files[i];
          if(!file.trashed)
          {
            var msg = "backupfile is being created, please wait ...<br>adding file <b>" + file.name + "</b> hinzu";
            __cloudData.self.requestData(file.name,"",__cloudData.self,__cloudData.self._packBackupFile,msg,false);
/*
            var req = gapi.client.drive.files.get(
            {
              "fileId": file.id
             ,"alt": "media"
             ,"fields": "files(idx,name,trashed)"
            });
            req.then(function(content,cont)
            {
              __cloudData.self.$.overlay.text = "Backupdatei wird erstellt, bitte warten ...<br>Füge Datei <b>" + file.name + "</b> hinzu";
              __cloudData.self._zip.file(file.name, __cloudData.self._decode(content.body));
            });
            return;
//*/
          }
        }
        __cloudData.self.dataRequests.push(["_saveZip",zipfilename]);
        __cloudData.self._endRequest("getBackupFile");
      });
    },
    _packBackupFile: function(self, status, data)
    {
      if(status != "ok")
      {
        self._msg("file " + data.id + " could not be packed.");
        return;
      }
      var name = data._id + "." + data._ext;
      if(data.content)
        self._zip.file(name, self._decode(data.content));
      else
        self._zip.file(name, JSON.stringify(data));
    },
    /**
     * Get a backupfile in zip-format.
     *
     * @param {String}  filemask     the filemask for the files.
     * @param {String}  zipfilename  name of the zipfile for download.
     */
    getBackupFile: function(filemask,zipfilename)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["getBackupFile",filemask,zipfilename]);
        return;
      }

      if(this.$.overlay.isCanceled)
        return;

      __cloudData = {self:this, id:filemask};
      this.$.overlay.showCancelButton = true;
      this._callGoogleApi("backupfile is being created...",this.scDrive,function(authResult)
      {
        gapi.client.load("drive","v3",function()
        {
          __cloudData.self._getBackupFiles(zipfilename);
        });
      });
    },
    /**
      * Creates a zip-file from the content of the internal variable
      * _zip and presents the user a save as dialog.
      *
      * @param {String} zipfilename    Name of the zip-file to recommend to the user.
      */
    _saveZip: function(zipfilename)
    {
      __cloudData = undefined;
      this.$.overlay.close();
      var content = this._zip.generateAsync({type:"blob"}).then(function(content)
      {
        saveAs(content,zipfilename);
      });
      this.$.overlay.showCancelButton = false;
    },
    /**
     * Calls the google api for sheets.
     *
     * @param {Object}  parent   the parent that will be given as parameter to onDone. Since
     *                           the variable "this" is this class when invoking the onDone-
     *                           callback, parent should be set to the object, that contains the
     *                           functions onSuccess and onError.
     *
     * @param {String}  id       id of the calling function.
     *
     * @param {String} msg       message to display on overlay.
     *
     * @param {Event}  onSuccess the function that gets called when api was loaded.
     *
     * @param {Event}  onError   the function that gets called when api could not be loaded.
     *
     * the function onSuccess is called without parameters.
     *
     * the function onError receives this parameters:
     *
     * {Object} self   the parent parameter.
     *
     * {String} status always the string "error".
     *
     * {Object} error  the error object.
     */
    _callGoogleSheetsApi: function(parent,id,msg,onSuccess,onError)
    {
      this._callGoogleApi(msg,this.scSheets,function(authResult)
      {
        gapi.client.load("https://sheets.googleapis.com/$discovery/rest?version=v4").then(function()
        {
          if(onSuccess)
            onSuccess();
        }, function(error)
        {
          __cloudData.self._apiError(parent,id,error,onError);
        });
      }, function(error)
      {
        __cloudData.self._apiError(parent,id,error,onError);
      });
    },
    /**
     * Is called, when an error occurs when calling the google sheets api.
     *
     * @param {Object}  parent   the parent that will be given as parameter to onError. Since
     *                           the variable "this" is this class when invoking the onError-
     *                           callback, parent should be set to the object, that contains the
     *                           function onError.
     *
     * @param {String}  id       id of the calling function.
     *
     * @param {String} msg       message to display on overlay.
     *
     * @param {Event}  onSuccess the function that gets called when api was loaded.
     *
     * @param {Event}  onError   the function that gets called when api could not be loaded.
     *
     * the function onSuccess is called without parameters.
     *
     * the function onError receives this parameters:
     *
     * {Object} self   the parent parameter.
     *
     * {String} status always the string "error".
     *
     * {Object} error  the error object.
     */
    _apiError: function(parent,id,error,onError)
    {
      if(onError)
        onError(parent,"error",error.result.error);
      __cloudData.self._msg(error.result.error.message);
      __cloudData.self._endRequest(id);
    },
    /**
     * Retrieve info about a google sheet.
     *
     * @param {Object}  parent       the parent that will be given as parameter to onDone. Since
     *                               the variable "this" is this class when invoking the onDone-
     *                               callback, parent should be set to the object, that contains the
     *                               function onDone.
     *
     * @param {Event}   onDone       the function that gets called when loading is done.
     *
     * the function onDone receives this parameters:
     *
     * {Object} self    the parent parameter.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} sheets  an array of sheets information the error data.
     */
    loadSheetInfo: function(parent,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["loadSheetInfo",parent,onDone]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleSheetsApi(parent,"loadSheetInfo","loading Sheetinfo...",function()
      {
        var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                   ,fields: "sheets.properties"};
        gapi.client.sheets.spreadsheets.get(args).then(function(response)
        {
          if(onDone)
          {
            var sheets = [];
            for(var i=0; i<response.result.sheets.length; i++)
              sheets.push(response.result.sheets[i].properties);
            onDone(parent,"ok",sheets);
          }
          __cloudData.self._endRequest("loadSheetInfo");
        }, function(error)
        {
          __cloudData.self._apiError(parent,"loadSheetInfo",error,onDone);
        });
      },onDone);
    },
    /**
     * Retrieve data from a google sheet.
     *
     * @param {Object}  parent         the parent that will be given as parameter to onDone. Since
     *                                 the variable "this" is this class when invoking the onDone-
     *                                 callback, parent should be set to the object, that contains the
     *                                 function onDone
     * @param {String   range          range of cells to be loaded. if this is an array, then every entry
     *         or                      in this array is considered a range to receive.
     *         Array}
     * @param {Event}   onDone         the function that gets called when loading is done.
     *
     * the function onDone receives this parameters:
     *
     * {Object} self    the parent parameter.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} data    the data that was loaded or the json-data of the error
     *
     * {String} range   the range parameter.
     *
     */
    readSheetData: function(parent,range,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["readSheetData",parent,range,onDone]);
        return;
      }

      __cloudData = {self:this};

      this._callGoogleSheetsApi(parent,"readSheetData","reading range " + range + "...",function()
      {
        var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                   ,range: range
                   ,valueRenderOption: "UNFORMATTED_VALUE"};
        if(range.constructor === Array)
        {
          delete args.range;
          args.ranges = range;
          args.majorDimension = "ROWS";
          gapi.client.sheets.spreadsheets.values.batchGet(args).then(function(response)
          {
            if(onDone)
              onDone(parent,"ok",response.result.valueRanges,range);
            __cloudData.self._endRequest("readSheetData");
          }, function(error)
          {
            __cloudData.self._apiError(parent,"readSheetData",error,onDone);
          });
        }
        else
        {
          gapi.client.sheets.spreadsheets.values.get(args).then(function(response)
          {
            if(onDone)
              onDone(parent,"ok",response.result.values,range);
            __cloudData.self._endRequest("readSheetData");
          }, function(error)
          {
            __cloudData.self._apiError(parent,"readSheetData",error,onDone);
          });
        }
      }, onDone);
    },
    /**
     * Write data to a google sheet.
     *
     * @param {Object}  parent         the parent that will be given as parameter to onDone. Since
     *                                 the variable "this" is this class when invoking the onDone-
     *                                 callback, parent should be set to the object, that contains the
     *                                 function onDone
     * @param {String}  range          range of cells to be written. if this is empty then the data is
     *                                 considered to be written with batchUpdate.
     *
     * @param {Object}  data           data to write.
     *
     * @param {Event}   onDone the function that gets called when writing is done.
     *
     * the function onDone receives this parameters:
     *
     * {Object} self    the parent parameter.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} data    result of the write operation.
     *
     * {String} range   the range parameter.
     */
    writeSheetData: function(parent,range,data,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["writeSheetData",parent,range,data,onDone]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleSheetsApi(parent,"writeSheetData","writing range " + range + "...",function()
      {
        if(range == "" || range == undefined)
        {
          var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                     ,requests:data};
          gapi.client.sheets.spreadsheets.batchUpdate(args).then(function(response)
          {
            if(onDone)
              onDone(parent,"ok",response.result,range);
            __cloudData.self._endRequest("writeSheetData");
          }, function(error)
          {
            __cloudData.self._apiError(parent,"writeSheetData",error,onDone);
          });
        }
        else
        {
          var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                     ,majorDimension: "ROWS"
                     ,range: range
                     ,values: data
                     ,valueInputOption: "USER_ENTERED"};
          gapi.client.sheets.spreadsheets.values.update(args).then(function(response)
          {
            if(onDone)
              onDone(parent,"ok",response.result,range);
            __cloudData.self._endRequest("writeSheetData");
          }, function(error)
          {
            __cloudData.self._apiError(parent,"writeSheetData",error,onDone);
          });
        }
      },onDone);
    },
    /**
     * Add a page to google sheet.
     *
     * @param {Object}  parent         the parent that will be given as parameter to onDone. Since
     *                                 the variable "this" is this class when invoking the onDone-
     *                                 callback, parent should be set to the object, that contains the
     *                                 function onDone
     * @param {String}  title          title of the new sheet.
     *
     * @param {Event}   onDone         the function that gets called when adding is done.
     *
     * the function onDone receives this parameters:
     *
     * {Object} self    the parameter parent.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} data    the sheet or the error information.
     *
     * {Object} title   the parameter title.
     *
     * if onDone returns an array then this array is executed as a request for updateBatch on
     * the added sheet.
     */
    addSheet: function(parent,title,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["addSheet",parent,title,onDone]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleSheetsApi(parent,"addSheet","adding sheet " + title + "...",function()
      {
        var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                   ,requests:[{addSheet:{properties:{title: title}}}]
                   };
        
        gapi.client.sheets.spreadsheets.batchUpdate(args).then(function(response)
        {
          if(onDone)
          {
            var request = onDone(parent,"ok",response.result.replies[0].addSheet.properties,title);
            if(request != undefined && request.constructor === Array)
            {
              args.requests = request;
              gapi.client.sheets.spreadsheets.batchUpdate(args).then(function(response)
              {
                __cloudData.self._endRequest("addSheet");
              }, function(error)
              {
                __cloudData.self._apiError(parent,"addSheet",error,onDone);
              });
            }
            else
            {
              __cloudData.self._endRequest("addSheet");
            }
          }
          else
          {
            __cloudData.self._endRequest("addSheet");
          }
        }, function(error)
        {
          __cloudData.self._apiError(parent,"addSheet",error,onDone);
        });
      }, onDone); 
    },
    /**
     * Create a new spreadsheet-file.
     *
     * @param {Object}  parent         the parent that will be given as parameter to onDone. Since
     *                                 the variable "this" is this class when invoking the onDone-
     *                                 callback, parent should be set to the object, that contains the
     *                                 function onDone
     *
     * @param {String}  name           name of the new file.
     *
     * @param {Event}   onDone         the function that gets called when everything is done.
     *
     * the function onDone receives this parameters:
     *
     * {Object} self    the parent parameter.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} sheet   result of the operation.
     *
     * {Object} name    the name parameter.
     */
    createSpreadsheet: function(parent,name,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["createSpreadsheet",parent,name,onDone]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleSheetsApi(parent,"createSpreadsheet","creating spreadsheet " + name + "...",function()
      {
        gapi.client.sheets.spreadsheets.create().then(function(response)
        {
          if(onDone)
            onDone(parent,"ok",response.result,name);
          __cloudData.self._endRequest("createSpreadsheet");
        }, function(error)
        {
          __cloudData.self._apiError(parent,"createSpreadsheet",error,onError);
        });
      }, onDone);
    },
    /**
     * Copy a sheet.
     *
     * @param {Object}  parent    the parent that will be given as parameter to onDone. Since
     *                            the variable "this" is this class when invoking the onDone-
     *                            callback, parent should be set to the object, that contains the
     *                            function onDone.
     *
     * @param {String}  id        id of the sheet to copy.
     *
     * @param {String}  newName   title of the new sheet.
     *
     * @param {Event}   onDone    the function that gets called when adding is done.
     *
     * the function onSheetCopied receives this parameters:
     *
     * {Object} self    the parent parameter.
     *
     * {String} status  the status of the operation:
     *
     *                  "ok"        everything is fine.
     *
     *                  "error"     the data property contains an object with the error.
     *
     * {Object} sheet   result of the add operation.
     *
     * {String} id      the id parameter.
     *
     * {String} newName the newName parameter.
     */
    copySheet: function(parent,id,newName,onDone)
    {
      if(__cloudData != undefined)
      {
        this.dataRequests.push(["copySheet",parent,id,newName,onDone]);
        return;
      }

      __cloudData = {self:this};
      this._callGoogleSheetsApi(parent,"copySheet","copying sheet " + id + " to " + name + "...",function()
      {
        var args = {spreadsheetId:__cloudData.self.googleSheetsFileId
                   ,requests:
                    [
                     {
                       duplicateSheet:
                       {
                         sourceSheetId: id
                        ,insertSheetIndex: 9999
                        ,newSheetName: newName
                       }
                     }
                    ]
                   };
        gapi.client.sheets.spreadsheets.batchUpdate(args).then(function(response)
        {
          if(onDone)
            onDone(parent,"ok",response.result.replies[0].duplicateSheet.properties,id,name);
          __cloudData.self._endRequest("copySheet");
        }, function(error)
        {
          __cloudData.self._apiError(parent,"copySheet",error,onDone);
        });
      }, onDone);
    }
  });
</script>
